<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <!-- Created by , GNU Texinfo 7.0.1 -->
  <head>
    <meta charset="utf-8" />
    <title></title>
    <!-- <meta name="viewport" content="width=device-width,initial-scale=1.0" /> -->
    
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"" />
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous"> -->
    <link rel="stylesheet" type="text/css" href="mystyle.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/a11y-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <div class="container">
      <h3>ffmpeg使用</h3>
        <li>List Devices</li>
            <pre><code>ffmpeg -list_devices true -f dshow -i dummy
ffmpeg -hide_banner -devices</code></pre>
            <li>Start Recording Camera (AVI Format)</li>
            <pre><code>ffmpeg -f dshow -i video="USB2.0 PC CAMERA" -c:v libx264 -preset ultrafast -qp 0 output.avi
ffmpeg -f dshow -i video="USB2.0 PC CAMERA" -c:v h464 -preset ultrafast -qp 0 output.avi
ffmpeg -f dshow -i video="USB2.0 PC CAMERA" -c:v h464 -preset medium output.avi</code></pre>
            <li>Screen Recording (Requires FFmpeg with x11grab)</li>
            <pre><code>ffmpeg -f x11grab -framerate 25 -video_size 1366x768 -i :0.0 -c:v libx264 -preset ultrafast out.mp4 ffmpeg -f x11grab -framerate 25 -video_size 1366x768 -i :0.0 -c:v libx264 -preset ultrafast out.mp4</code></pre>
        </ul></li>
        <li><a id="toc-Compilation" href="#Compilation">2 Compilation</a>
            
            <p>Here's an example:</p>

<dl class="section note">
  <dt>Note</dt>
  <dd>
    When using one of the JavaScript module variants of
    <code>janus.js</code>
    , you will need to import the
    <code>Janus</code>
    symbol from the module first. See also:
    <a href="js-modules.html" class="el">Using janus.js as JavaScript module</a>
    For example, using the ECMAScript module variant, the above example should
    be altered to:
  </dd>
</dl>
<pre><code>
import * as Janus from './janus.es.js'

Janus.init({
   debug: true,
   dependencies: Janus.useDefaultDependencies(), // or: Janus.useOldDependencies() to get the behaviour of previous Janus versions
   callback: function() {
           // Done!
   }
});</code></pre>
<p>
  Once the library has been initialized, you can start creating sessions.
  Normally, each browser tab will need a single session with the server: in
  fact, each Janus session can contain several different plugin handles at the
  same time, meaning you can start several different WebRTC sessions with the
  same or different plugins for the same user using the same Janus session. That
  said, you're free to set up different Janus sessions in the same page, should
  you prefer so.
</p>
<p>
  Creating a session is quite easy. You just need to use the
  <code>new</code>
  constructor to create a new
  <code>Janus</code>
  object that will handle your interaction with the server. Considering the
  dynamic and asynchronous nature of Janus sessions (events may occur at any
  time), there are several properties and callbacks you can configure when
  creating a session:
</p>
<ul>
  <li>
    <code>server:</code>
    the address of the server as a specific address (e.g.,
    <a href="http://yourserver:8088/janus">http://yourserver:8088/janus</a>
    to use the plain HTTP API or ws://yourserver:8188/ for WebSockets) or as an
    array of addresses to try sequentially to allow automatic for
    fallback/failover during setup;
  </li>
  <li>
    <code>iceServers:</code>
    a list of STUN/TURN servers to use (a default STUN server will be used if
    you skip this property);
  </li>
  <li>
    <code>withCredentials:</code>
    whether the
    <code>withCredentials</code>
    property of XHR requests should be enabled or not (false by default, and
    only valid when using HTTP as a transport, ignored for WebSockets);
  </li>
  <li>
    <code>max_poll_events:</code>
    the number of events that should be returned when polling; the default is 1
    (polling returns an object), passing a higher number will have the backend
    return an array of objects instead (again, only valid for HTTP usage as this
    is strictly related to long polling, ignored for WebSockets);
  </li>
  <li>
    <code>destroyOnUnload:</code>
    whether we should destroy automatically try and destroy this session via
    Janus API when
    <code>onbeforeunload</code>
    is called (true by default);
  </li>
  <li>
    <code>token</code>
    ,
    <code>apisecret:</code>
    optional parameters only needed in case you're
    <a href="auth.html" class="el">Authenticating the Janus API</a>
    ;
  </li>
  <li>
    a set of callbacks to be notified about events, namely:
    <ul>
      <li>
        <code>success:</code>
        the session was successfully created and is ready to be used;
      </li>
      <li>
        <code>error:</code>
        the session was NOT successfully created;
      </li>
      <li>
        <code>destroyed:</code>
        the session was destroyed and can't be used any more.
      </li>
    </ul>
  </li>
</ul>
<p>
  These properties and callbacks are passed to the method as properties of a
  single parameter object: that is, the
  <code>Janus</code>
  constructor takes a single parameter, which although acts as a container for
  all the available options. The
  <code>success</code>
  callback is where you typically start your application logic, e.g., attaching
  the peer to a plugin and start a media session.
</p>
<p>Here's an example:</p>
<pre><code>
var janus = new Janus(
    {
        server: 'http://yourserver:8088/janus',
        success: function() {
            // Done! attach to plugin XYZ
        },
        error: function(cause) {
            // Error, can't go on...
        },
        destroyed: function() {
            // I should get rid of this
        }
    });</code></pre
>
<p>As anticipated, the server may be a specific address, e.g.:</p>
<pre class="fragment card card-body bg-gray">
var janus = new Janus(
    {
        server: 'http://yourserver:8088/janus',
                // or
        server: 'ws://yourserver:8188/',
        [..]</pre
>
<p>
  or an array of addresses. Such an array can be especially useful if you want
  the library to first check if the WebSockets server is reachable and, if not,
  fallback to plain HTTP, or just to provide a link multiple instances to try
  for failover. This is an example of how to pass a 'try websockets and fallback
  to HTTP' array:
</p>
<pre class="fragment card card-body bg-gray">
var janus = new Janus(
    {
        server: ['ws://yourserver:8188/','http://yourserver:8088/janus'],
        [..]</pre
>
<p>
  Once created, this object represents your session with the server. you can
  interact with a
  <code>Janus</code>
  object in several different ways. In particular, the following properties and
  methods are defined:
</p>
<ul>
  <li>
    <code>getServer()</code>
    : returns the address of the server;
  </li>
  <li>
    <code>isConnected()</code>
    : returns
    <code>true</code>
    if the Janus instance is connected to the server,
    <code>false</code>
    otherwise;
  </li>
  <li>
    <code>getSessionId()</code>
    : returns the unique Janus session identifier;
  </li>
  <li>
    <code>attach(parameters)</code>
    : attaches the session to a plugin, creating a handle; more handles to the
    same or different plugins can be created at the same time;
  </li>
  <li>
    <code>destroy(parameters)</code>
    : destroys the session with the server, and closes all the handles (and
    related PeerConnections) the session may have with any plugin as well.
  </li>
</ul>
<p>
  The most important property is obviously the
  <code>attach()</code>
  method, as it's what will allow you to exploit the features of a plugin to
  manipulate the media sent and/or received by a PeerConnection in your web
  page. This method will create a plugin handle you can use for the purpose, for
  which you can configure properties and callbacks when calling the
  <code>attach()</code>
  method itself. As for the
  <code>Janus</code>
  constructor, the
  <code>attach()</code>
  method takes a single parameter that can contain any of the following
  properties and callbacks:
</p>
<ul>
  <li>
    <code>plugin:</code>
    the unique package name of the plugin (e.g.,
    <code>janus.plugin.echotest</code>
    );
  </li>
  <li>
    <code>opaqueId:</code>
    an optional opaque string meaningful to your application (e.g., to map all
    the handles of the same user);
  </li>
  <li>
    a set of callbacks to be notified about events, namely:
    <ul>
      <li>
        <code>success:</code>
        the handle was successfully created and is ready to be used;
      </li>
      <li>
        <code>error:</code>
        the handle was NOT successfully created;
      </li>
      <li>
        <code>consentDialog:</code>
        this callback is triggered just before
        <code>getUserMedia</code>
        is called (parameter=
        <b>true</b>
        ) and after it is completed (parameter=
        <b>false</b>
        ); this means it can be used to modify the UI accordingly, e.g., to
        prompt the user about the need to accept the device access consent
        requests;
      </li>
      <li>
        <code>webrtcState:</code>
        this callback is triggered with a
        <b>true</b>
        value when the PeerConnection associated to a handle becomes active (so
        ICE, DTLS and everything else succeeded) from the Janus perspective,
        while
        <b>false</b>
        is triggered when the PeerConnection goes down instead; useful to figure
        out when WebRTC is actually up and running between you and Janus (e.g.,
        to notify a user they're actually now active in a conference); notice
        that in case of
        <b>false</b>
        a reason string may be present as an optional parameter;
      </li>
      <li>
        <code>iceState:</code>
        this callback is triggered when the ICE state for the PeerConnection
        associated to the handle changes: the argument of the callback is the
        new state as a string (e.g., "connected" or "failed");
      </li>
      <li>
        <code>mediaState:</code>
        this callback is triggered when Janus starts or stops receiving your
        media: for instance, a
        <code>mediaState</code>
        with mid=
        <b>0</b>
        , type=
        <b>audio</b>
        and on=
        <b>true</b>
        means Janus started receiving the audio stream identified by mid
        <code>b</code>
        in the offer/answer exchange and transceivers (or started getting them
        again after a pause of more than a second); a
        <code>mediaState</code>
        with type=
        <b>video</b>
        and on=
        <b>false</b>
        means Janus hasn't received any video from you in the last second, after
        a start was detected before; useful to figure out when Janus actually
        started handling your media, or to detect problems on the media path
        (e.g., media never started, or stopped at some time);
      </li>
      <li>
        <code>slowLink:</code>
        this callback is triggered when Janus reports trouble either sending or
        receiving media on the specified PeerConnection, typically as a
        consequence of too many NACKs received from/sent to the user in the last
        second: for instance, a
        <code>slowLink</code>
        with uplink=
        <b>true</b>
        means you notified several missing packets from Janus, while uplink=
        <b>false</b>
        means Janus is not receiving all your packets; useful to figure out when
        there are problems on the media path (e.g., excessive loss), in order to
        possibly react accordingly (e.g., decrease the bitrate if most of our
        packets are getting lost);
      </li>
      <li>
        <code>onmessage:</code>
        a message/event has been received from the plugin;
      </li>
      <li>
        <code>onlocaltrack:</code>
        a local
        <code>MediaStreamTrack</code>
        is available and ready to be displayed;
      </li>
      <li>
        <code>onremotetrack:</code>
        a remote
        <code>MediaStreamTrack</code>
        is available and ready to be displayed;
      </li>
      <li>
        <code>ondataopen:</code>
        a Data Channel is available and ready to be used;
      </li>
      <li>
        <code>ondata:</code>
        data has been received through the Data Channel;
      </li>
      <li>
        <code>oncleanup:</code>
        the WebRTC PeerConnection with the plugin was closed;
      </li>
      <li>
        <code>detached:</code>
        the plugin handle has been detached by the plugin itself, and so should
        not be used anymore.
      </li>
    </ul>
  </li>
</ul>
<p>Here's an example:</p>
<pre class="fragment card card-body bg-gray">
// Attach to echo test plugin, using the previously created janus instance
janus.attach(
    {
        plugin: "janus.plugin.echotest",
        success: function(pluginHandle) {
            // Plugin attached! 'pluginHandle' is our handle
        },
        error: function(cause) {
            // Couldn't attach to the plugin
        },
        consentDialog: function(on) {
            // e.g., Darken the screen if on=true (getUserMedia incoming), restore it otherwise
        },
        onmessage: function(msg, jsep) {
            // We got a message/event (msg) from the plugin
            // If jsep is not null, this involves a WebRTC negotiation
        },
        onlocaltrack: function(track, added) {
            // A local track to display has just been added (getUserMedia worked!) or removed
        },
        onremotetrack: function(track, mid, added, metadata) {
            // A remote track (working PeerConnection!) with a specific mid has just been added or removed
            // You can query metadata to get some more information on why track was added or removed
            // metadata fields:
            //   - reason: 'created' | 'ended' | 'mute' | 'unmute'
        },
        oncleanup: function() {
            // PeerConnection with the plugin closed, clean the UI
            // The plugin handle is still valid so we can create a new one
        },
        detached: function() {
            // Connection with the plugin closed, get rid of its features
            // The plugin handle is not valid anymore
        }
    });</pre
>
<p>
  So the
  <code>attach()</code>
  method allows you to attach to a plugin, and specify the callbacks to invoke
  when anything relevant happens in this interaction. To actively interact with
  the plugin, you can use the
  <code>Handle</code>
  object that is returned by the
  <code>success</code>
  callback (pluginHandle in the example).
</p>

  </body>
</html>
